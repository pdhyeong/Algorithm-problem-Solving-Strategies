### 다항시간 알고리즘

변수 N과 N^2, 그 외N의 거듭제곱을의 선형 결합으로 이루어진 식들을 다항식이라고 부른다.

반복문의 수행 횟수를 입력 크기의 다항식으로 표현할 수 있는 알고리즘들을  다항시간 알고리즘이라고 한다.

같은 다항 시간 알고리즘이라도 엄청 나게 큰 시간 차이가 날 수 있는데 N이나 N^100 둘다 다항시간알 고리즘이라고 하기 때문이다.

이들을 묶어서 이름을 붙인 이유는 다항 시간보다 더더욱 오래걸리는 알고리즘들이 존재하기 때문이다.

### 알러지가 심한 친구들

집들이에 N명의 친구를 초대하려고 한다. 할 줄 아는 M가지의 음식중 무엇을 대접해야 할까를 고민하는데, 친구들은 각각 알러지 때문에

못 먹는 음식들이 있어서 아무 음식이나 해서는 안 된다. 만들 줄 아는 음식의 목록과, 해당 음식을 못 먹는 친구들의 목록이 표 A와 같이 있다면

각 친구가 먹을 수 있는 음식이 최소 하나씩은 있으려면 최소 몇 가지의 음식을 해야할까?

**표A**
|이름|갈비찜|피자|잡채|떡볶이|탕수육|닭강정|
|---|---|---|---|---|---|---|
|페이|X|O|O|O|X|X|
|지아|X|X|X|X|O|O|
|민|O|X|O|X|O|X|
|수지|O|O|X|X|X|O|


표A와 같다면 다 같이 먹을수 있는 음식이 없기때문에 결국 두 가지 이상 음식을 해야한다.

피자와 탕수육,혹은 잡채와 닭강정처럼 두 개 이상의 음식을 선택해야만 모두가 음식을 먹을 수 있다.

### 모든 답 후보를 평가하기

여러개의 답이 있겠지만 우리는 더 적은 종류의 음식을 하려고한다.

그중 가장 좋은 답을 찾는 방법은 일일히 모든 것을 고려해 보는것이다.

만들 수 있는 음식의 모든 목록을 만드는 과정은 여러 개의 결저으로 나누면 자연스럽다.

첫번째 요리를 만들지 말지를 결정하고 그 다음 두번째 요리를 만들지 말지를 결정하는 식으로 말이다.

식사를 할 수 있는 목록들만을 골라낸 뒤 가장 음식의 수가 적은 목록을 찾으면 된다.

```C++
const int INF = 1ef;

// 해당 메뉴로 모두가 식사를 할 수 있는지 여부
bool canEverybodyEat(const vector<int>& menu) ;

// 음식의 수
int M;

//food번째 음식을 만들지 여부를 결정
int selectMenu(vector<int> & menu, int food) {

  // 모든 음식에 대해 만들지 여부를 결정
  if(food == M) {
    if(canEverybodyEat(menu)) return menu.size();
    // 아무것도 못 먹는 사람이 있으면 아주 큰 값을 반환
    return INF;
   }
   
   // 이 음식을 만들지 않는 경우 답을 계산
   int ret = selectMenu(menu,food+1);
   
   // 음식을 만드는 경우 답을 계싼해서 더 작은 값을 가진다.
   menu.push_back(food);
   ret = min(ret,selectMenu(menu,food+1));
   menu.pop();
   
   return ret;
   
}
```
### 지수시간 알고리즘

위 프로그램은 모든 답을 한번씩 다확인하기 때문에 전체 걸리는 시간은 만들 수 있는 답의 수에 비례하게 된다.

M가지의 음식마다 만든다, 만들지 않는다 라는 두가지 선택지가 있기 때문에 2^M가지이다.

답을 하나 만들때마다 canEverybodyEat()을 수행하니 이 알고리즘의 수행 시간은 2^M을 곱한 것이 된다.

전체 수행 시간은 N-M * 2^M 이 된다.

지수 알고리즘은 N이 하나 증가 할 때무다 수행 시간이 말도 안되게 빠르게 증가한다.

위 문제는 집합 덮개(set cover)라고 부르는 유명한 문제지만 다항 시간 알고리즘으로 동작한다는 존재도 아직 증거도 발견하기 못했다.

그렇다고 굉장히 오래걸린다고 착각하면 안된다고 한다. 전산학에는 지수시간보다 빠른 알고리즘을 찾지 못한 문제들이 넘치기때문이다.

계산적으로는 어려운 문제들이라고 해서 더 잘할수 이쓴ㄴ 방법이 없는 것은 아니지만 그나마 더 '조금'더 빠르게 동작할 수 있는 방법이 있기 때문이다.

### 소인수 분해의 수행 시간

입력으로 주어지는 숫자의 개수가 아니라 크기에 따라 수행 시간이 달라지는 알고리즘 또한 지수 수행 시간을 가질 수 있다.

소인수 분해 알고리즘은 N이 1이 될 때까지 가능한 한 모든 숫자로 N을 나눠본다.

그러면 N의 크기에 따라 반복문의 수행 횟수가 달라지게 되는데 가능한 최악의 경우는 N이 소수인 경우이다.

```C++
// 가장 간단한 형태의 소인수 분해 알고리즘

// n의 소인수 분해 결과를 담은 정수 배열을 반환
vector<int> factor(int n) {
  if(n == 1) return vector<int>(1,1) ; // n == 1 면 예외처리
  for(int div = 2; n > 1; ++div) 
    while(n % div == 0) {
      n /= div;
      ret.push_back(div);
  }
  return ret;
}
```

이때 factor)는 div가 N에 도달할 때까지 숫자르 증가 시키며 하나하나 나누기를 시도한다.

결과적으로 반복문의 실행 횟수는 N-1이 된다. 실행 횟수가 대략 N에 비례하기 때문에 최악의 경우는 선형 시간이 걸린다고 생각하기 쉽지만

N이 아무리 커져도 실제 입력은 1개일 뿐인데 수행 시간이 달라진다는것은 직관에 맞지 않는 느낌을준다.

이런 불일치를 직관적으로 이해하기 위해 알고리즘의 수행 시간과 입력이 메모리에서 차지하는 공간의 관계를 생각해 보자.

이진 탐색, 이동 평균 계산 등 지금까지 다른 알고리즘에서는 입력의 값들이 일정 범위 내에 있다고 어렵지 않게 가정할 수 있었으나,

이 경우 입력의 개수와 메모리에서 차지하는 공간이 직접적으로 비례하게 된다.

소인수 분해 문제에서 입력으로 주어지는 숫자가 알고리즘의 동작에 직접적인 영ㅇ향을 미치므로, 숫자가 특정 범위 안에 있다고 가정할 수 없다.

즉, 입력이 차지하는 비트의 수에 따라 수행 시간이 증가한다고 생각함녀 아까의 불일치를 직관적으로 설명 할 수 있게 된다.

위 코드는 입력의 크기에 대해 지수 시간이 걸린다고 표현 가능하다.

