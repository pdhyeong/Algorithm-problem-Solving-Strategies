### 다항시간 알고리즘

변수 N과 N^2, 그 외N의 거듭제곱을의 선형 결합으로 이루어진 식들을 다항식이라고 부른다.

반복문의 수행 횟수를 입력 크기의 다항식으로 표현할 수 있는 알고리즘들을  다항시간 알고리즘이라고 한다.

같은 다항 시간 알고리즘이라도 엄청 나게 큰 시간 차이가 날 수 있는데 N이나 N^100 둘다 다항시간알 고리즘이라고 하기 때문이다.

이들을 묶어서 이름을 붙인 이유는 다항 시간보다 더더욱 오래걸리는 알고리즘들이 존재하기 때문이다.

### 알러지가 심한 친구들

집들이에 N명의 친구를 초대하려고 한다. 할 줄 아는 M가지의 음식중 무엇을 대접해야 할까를 고민하는데, 친구들은 각각 알러지 때문에

못 먹는 음식들이 있어서 아무 음식이나 해서는 안 된다. 만들 줄 아는 음식의 목록과, 해당 음식을 못 먹는 친구들의 목록이 표 A와 같이 있다면

각 친구가 먹을 수 있는 음식이 최소 하나씩은 있으려면 최소 몇 가지의 음식을 해야할까?

**표A**
|이름|갈비찜|피자|잡채|떡볶이|탕수육|닭강정|
|---|---|---|---|---|---|---|
|페이|X|O|O|O|X|X|
|지아|X|X|X|X|O|O|
|민|O|X|O|X|O|X|
|수지|O|O|X|X|X|O|


표A와 같다면 다 같이 먹을수 있는 음식이 없기때문에 결국 두 가지 이상 음식을 해야한다.

피자와 탕수육,혹은 잡채와 닭강정처럼 두 개 이상의 음식을 선택해야만 모두가 음식을 먹을 수 있다.

### 모든 답 후보를 평가하기

여러개의 답이 있겠지만 우리는 더 적은 종류의 음식을 하려고한다.

그중 가장 좋은 답을 찾는 방법은 일일히 모든 것을 고려해 보는것이다.

만들 수 있는 음식의 모든 목록을 만드는 과정은 여러 개의 결저으로 나누면 자연스럽다.

첫번째 요리를 만들지 말지를 결정하고 그 다음 두번째 요리를 만들지 말지를 결정하는 식으로 말이다.

식사를 할 수 있는 목록들만을 골라낸 뒤 가장 음식의 수가 적은 목록을 찾으면 된다.

```C++
const int INF = 1ef;

// 해당 메뉴로 모두가 식사를 할 수 있는지 여부
bool canEverybodyEat(const vector<int>& menu) ;

// 음식의 수
int M;

//food번째 음식을 만들지 여부를 결정
int selectMenu(vector<int> & menu, int food) {

  // 모든 음식에 대해 만들지 여부를 결정
  if(food == M) {
    if(canEverybodyEat(menu)) return menu.size();
    // 아무것도 못 먹는 사람이 있으면 아주 큰 값을 반환
    return INF;
   }
   
   // 이 음식을 만들지 않는 경우 답을 계산
   int ret = selectMenu(menu,food+1);
   
   // 음식을 만드는 경우 답을 계싼해서 더 작은 값을 가진다.
   menu.push_back(food);
   ret = min(ret,selectMenu(menu,food+1));
   menu.pop();
   
   return ret;
   
}
```
### 지수시간 알고리즘

위 프로그램은 모든 답을 한번씩 다확인하기 때문에 전체 걸리는 시간은 만들 수 있는 답의 수에 비례하게 된다.

M가지의 음식마다 만든다, 만들지 않는다 라는 두가지 선택지가 있기 때문에 2^M가지이다.

답을 하나 만들때마다 canEverybodyEat()을 수행하니 이 알고리즘의 수행 시간은 2^M을 곱한 것이 된다.

전체 수행 시간은 N-M * 2^M 이 된다.

지수 알고리즘은 N이 하나 증가 할 때무다 수행 시간이 말도 안되게 빠르게 증가한다.

위 문제는 집합 덮개(set cover)라고 부르는 유명한 문제지만 다항 시간 알고리즘으로 동작한다는 존재도 아직 증거도 발견하기 못했다.

그렇다고 굉장히 오래걸린다고 착각하면 안된다고 한다. 전산학에는 지수시간보다 빠른 알고리즘을 찾지 못한 문제들이 넘치기때문이다.

계산적으로는 어려운 문제들이라고 해서 더 잘할수 이쓴ㄴ 방법이 없는 것은 아니지만 그나마 더 '조금'더 빠르게 동작할 수 있는 방법이 있기 때문이다.

### 소인수 분해의 수행 시간

