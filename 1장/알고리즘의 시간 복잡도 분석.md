## 도입

좀더 빠른 알고리즘을 만들기 위해 가장 먼저 해야 할 일은 바로 알고리즘 속도를 어떻게 측정할지를 정하는 것.

알고리즘의 속도를 츨정할 수 없다면 알고리즘을 바꿨을 때 이것이 더 빨라졌는지 더 느려졌는지도 알수 없기 때문

이것이 기준을 잡기 어려운 이유는 사용하는 언어, 하드웨어 , 운영체제 , 컴파일러까지 수많은 요소에 따라 바뀌기 때문이다.

그렇다면 알고리즘 수행 시간을 어떤 기준으로 측정해야 할까

### 반복문이 지배한다.

한 가지 항목이 전체의 대소를 좌지우지 하는 것을 지배(dominate) 한다고 표현한다.

알고리즘의 수행 시간을 지배하는 것은 무엇일까?

바로 반복문이다. 대개 입력의 크기에 따라 수행 횟수가 정해지는 반복문이 있기 마련이다. 

짧은 거리를 달릴 때는 자동차보다 자전거가 빠를 수 있는 것처럼 입력의 크기가 작을 때는 반복외의 다른 부분들이

갖는 비중이 클 수 있지만, 입려의 크기가 커지면 커질 수록 반복문이 알고리즘의 수행 시간을 지배하게 된다.

대개 우리는 알고리즘의 수행 시간을 반복문이 수행되는 횟수로 측정합니다.

반복문의 수행 횟수는 입력의 크기에 대한 함수로 표현한다.

```C++
int majority1(const vector<int>& A)
{
	int N = A.size();
	int majority = -1, majorcount = 0;
	for (int i = 0; i < N; i++)
	{
		int V = A[i], count = 0;
		for (int j = 0; j < N; j++)
		{
			if (A[j] == V)
			{
				count++;
			}
		}
		if (count > majority)
		{
			majorcount = count;
			majority = V;
		}
	}
	return majority;
}
```

이와 같은 알고리즘은 수행시간이 N의 ^2 만큼의 연산을 반복했으므로 O(n^2)가 나온다.

숫자의 범위가 작다면 배열을 이용해서 각 숫자가 등장하는 횟수를 쉽게 샐수 있으므로

빈도수 배열을 순회함녀서 최대치의 위치를 찾으면 된다.

하나는 N번수행되고 다른 하나는 100번 수행되므로  전체 반복횟수는 N+100이다.

이 알고리즘의 수행 시간은 O(N)이라고 쓴다.

```C++
int majority2(const vector<int>& A)
{
	int N = A.size();
	vector<int> count(101, 0);
	for (int i = 0; i < N; i++)
	{
		count[A[i]]++;
	}
	int majority = 0;
	for (int i = 1; i <= 100; i++)
	{
		if (count[i] > count[majority]) {
			majority = i;
		}
	}
	return majority;
}
```
