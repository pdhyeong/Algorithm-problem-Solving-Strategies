### 산술 오버플로

컴퓨터는 수학자들이 만들어서 수학에 따라 움직인다.

하지만 현실세계에 존재하므로 유한성이 존재한다. 컴퓨터에 모든 변수에는 담을수 있는 크기가 제한되어있다.

수학적/논리적으로 완전히 정당한 알고리즘도 예상과 다르게 동작하는 경우를 흔하게 볼 수 있다.

    1. 대부분 프로그래밍 언어에서 사칙연산 과정에서 오버플로가 나도 경고를 해주지 않는다.
    2. 프로그램 정당성을 검증할 때 프로그램 논리의 정확성에만 집중하면 산술 오버플로의 등장을 잊기 마련.

---------------------------------------

### 너무 큰 결과

당연하지만 프로그램이 출력해야할 결과가 우리가 흔히 사용하는 32비트 자료형 범위를 넘어가면 65비트 정수를 사용하거나 큰 정수 구현을 이용한다.

습관적으로 32비트 정수를 쓰는 실수가 꽤나 흔하기 때문에 조심해야한다.

큰 정수를 다를 때는 항상 변수의 형태에 주의하는 습관을 가져야한다.

----------------------------------------

### 너무 큰 중간 값

산술 오버플로가 문제가 되는 또 다른 대표적인 경우는 프로그램의 출력 값의 범위는 작지만 중간 과정에서 큰 값을 일시적으로

계산해야 하는 경우이다. 

// 최대공약수 함수

int gcd(int a,int b) 

<br>

// 최소 공배수

int lcm(int a,int b)  = (a*b) / gcd(a,b) 이다.

즉 

```C++
int lcm(int a,int b){ return (a*b) / gcd(a,b)}
```
로 표현이 가능한대 다음에 lcm(50000,100000)을 넣으면 엉뚱한 값이 나오는데 이유는 계산 중간중 32비트 정수 범위를 넘어가기 때문에

결과 값은 논리적으로 표현이 가능하지만 중간 값이 너무 크기 때문에 중간 값이 너무 커도 오류가 난다.

--------------------------------

### 너무 큰 '무한대' 값

프로그래밍을 하다가 보면 무한대 값으로 정해줄 때가 편리할 때가 있는데

예를 들어 최단경로를 확인할때가 있다.

최단 경로를 탐색 할때 무한대값들 끼리 서로 더해지거나 곱해지는 경우를  잘 살펴 보고 오버플로가 나지 않게 유의해야한다.

------------------------------------

### 오버플로 피해가기

오버플로 발생 사실을 확인후 어떻게 고쳐야할까 ? 가장 간단한 방법은 더 큰 자료형을 사용하는 것.

예를 들어 좀전의 lcm()은 이러한 방법으로 쉽게 고칠 수 있다. 64비트의 정수형을 사용하면 되기 때문.

하지만 이항계수 처럼 n!/(n-r)r! 의 식을 계산할때 팩토리얼의 의해서 표현의 범위가 64비트를 넘어갈 우려가 있기 때문에

점화식을 이용하여 32비트 ㅈ어수형으로 표현이 가능하다.

---------------------------------

### 자료형의 프로모션

사칙연산이나 대소 비교 등의 이항 연산자들은 두개의 피연사자를 받는다. 만약 피연사자의 자료형이 다르거나 자료형의 범위가 너무 작은경우

컴파일러들은 대개 이들을 같은 자료형으로 변호나해서 계산하는데 이를, 프로모션이라고 한다.

##### 프로모션 ex) C++ 의 규칙
    1. 한쪽은 정수형이고 한쪽은 실수형일 경우 : 정수형이 실수형으로 변환
    2. 양쪽 다 정수형이거나 양쪽 다 실수형일 경우 : 보다 넓은 범위를 갖는 자료형으로 변환
    3. 양쪽 다 int형보다 작은 정수형인 경우 : 양쪽 다 int형으로 변환
    4. 부호 없는 정수형과 부호 있는 정수형이 섞여 있을 경우 : 부호 없는 정수형으로 변환
    
