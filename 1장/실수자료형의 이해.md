### 실수 연산의 어려움

수학의 영역에서 1/x * x = 1의 값을 반환해야하지만 컴퓨터에서 함수를 만들어 사용하면 결과 값이 그렇게 반환되지 않는다.

```C++
int countObvious(int n)
{
  int same = 0;
  for(int x = 1; x <= n; ++x)
  {
    double y = 1.0 / x;
    if(y * x == 1.0)
      ++same;
  }
  return same;
}
```
이와 같이 함수를 만들어 사용해서 50이란 값을 n에 넣으면 49가 반환 된다.

이는 컴퓨터가 사용하는 실수 표현 방식에 대해 알아야한다.

------------------------------------------------------

### 실수와 근사 값

우리가 일상적으로 다루는 정수들은 컴퓨터가 정확하게 표현이 가능하다.

하지만 실수를 다루게 되면 무한의 값도 존재할 수 있기 때문에

근사 값을 사용해야한다.

근사값은 실수의 계산에서 같은 수식을 두 번 계산 하더라도 어떤 순서로 계산하는지, 컴파일러 최적화는 켰는지 등에 여부에 따라 답이 달라질 수 있다.

-----------------------------------------------------

### IEEE 754

가장 많은 컴퓨터/컴파일러들에서 사용되는 실수 표기 방식은 IEEE 754 표준이라 한다. IEEE 754는 다음과 같은 특징이 있다.

    * 이진수로 실수를 표기
    * 부동 소수점(float-point)표기법
    * 무한대,비정규 수 등 의 특수 값이 존재
    
    
-------------------------------

### 실수의 이진법 표기

실수를 이진법으로 쓰는 방법은 간단하다.

12.34를 실수의 십진법 표기로 본다. 마지막 자리의 4가 5로 변한다면 전체 수는 0.01만큼 커진다. 그 앞자리의 3이 4로 변한다면

전체 수는 0.1만큼 커진다. 이렇게 소수점 바로 아래 자리의 3이 4로 변한다면 전체 수는 0.1만큼 커진다.

이렇게 소수점 바로 아래 자리의 크기는 1/10, 그 다음 자리의 크기는 1/100이 된다. 일반화 하면 소수점 밑 i번째 자리 크기는 1/10^i라고 표현

실수의 이진수 표기도 같은 방식으로 사용

소수점 밑 i번째 자리의 크기는 1/2^i

이진법으로 쓴 실수 1011.101의 경우 정수부인 1011은 2^3 + 2^1 + 2^0 = 11이다. 소수부 첫 짜리의 크기는 1/2,1/2^3 이므로 0.625가 되어 11.625로 표현

--------------------------

### 부동 소수점 표기

11.625를 이진법으로 쓰면 1011.101이 되고 소수점을 왼쪽으로 세칸 옮기면 1.011101이 된다. 이 수를 맨 앞에서부터 저장 공간이 허락하는 만큼

저장하는것. 이진법에서 소수점위에 있을 수 있는 유일한 숫자는 1이므로

IEEE 754에서는 1을 제외한 나머지를 저장하는 방식으로 1비트를 절약한다. 예를 들어 5비트만을 저장할 수 있다면 우리는 최상위 비트를 제외한 다음

5비트인  01110을 저장하게 된다. 이때 3가지 정보를 저장하게 되는데

    * 부호비트(sign bit): 양수인지 음수인지
    * 지수(exponent) : 소수점을 몇칸 옮겼나
    * 가수(mantisasa) : 소수점을 옮긴 실수의 최상위 X비트
    
지수와 가수가 갖는 비중을 어떻게 조절하느냐에 따라서 실수혀이 표현할 수 있는 숫자의 크기와 정확도가 결정된다.

IEEE 754를 만든 사람들은 실수형에서 지수보다 가수에 훨씬 많은 비트수를 부여하기로 결정했다.

32비트 실수형의 부호비트는 1비트 지수 비트는 8비트 가수 비트는 23비트로 표현 유효자리수는 6자리 이다.

64비트 실수형의 부호비트는 1비트 지수비트는 11비트 가수 비트는 52비트로 유효자릿수는 15자리이다.

때문에 웬만해서는 64비트 실수형 이상을 사용한다.

--------------------------------------------------------

### 실수 비교하기

위에서 말한 것 처럼 1/10 * 3과 3/10을 같은지를 비교하면 1/10과 3/10은 둘다 실수 변수의 정확하게 담을수 없고, 표현할 수 있는 

가장 가까운 실수로 근사해 표현 하게 된다.

IEEE 754에서 3/10을 담은 실수 변수는 참 값보다 작은 값, 1/10을 담은 실수 변수는 참 값보다 약간 큰 값으로 근사 된다.

두 근사 값은 모두 참 값인 3/10과 굉장히 가깝지만, 하나는 그보다 크고 하나는 그 보다 작아 비교가 실패된다.

두 실수를 비교할 때 어느 정도 오차를 염두에 두어야한다.

구체적으로는 두 값의 차이가 매우 작은 경우 두 값이 같다고 판단해야한다.

```C++
bool absoluteEqual(double a,double b)
{
  return fabs(a-b) < 1e-10;
}
```

a와 b가 같은지 판단하기 위한 함수로 미리 정해둔 오차 1/10^10 보다 작은지를 확인한다.

두수를 비교할 때 absoluteEqual()를 사용하면 위 처럼 countObvious()에 50을 넣었을때 50이 반환된다.

하지만 이 경우는 10^20/x * x를 비교한다고 가정했을때 오차 범위가 1/10^10을 초과하기 때문에 안전하지 않다.

이 문제를 해결하기 위해 크게 두 가지 방법을 사용할 수 있는데

#### 1. 비교할 실수의 크기들에 비례한 오차 한도를 정한다.

많은 경우 우리는 코드가 다루는 값의 범위를 예측할 수 있다.

한명이 내야할 삼겹살 가격이 500원 이거나 3천만원이 될 리는 없고 넓이가 1평방킬로미터인 동전이 있을리 없기 때문.

실제 입력으로 들어올 최대 값과 최소값을 대략 예측 술 수 있고 이들이 크게 차이 나지 않는 경우에는 하나의 오차한도값을 사용할 수 있다.

오차 한도값을 신중하게 결정해야한다.

경우에 따라서 정할 수 있는데

##### * 첫 번째 경우는 같다고 판단해야할 큰 값 두 개를 비교할 경우

두 실수 a, b를 비교했을때 오차한도값은 |a-b|보다 커야한다.

##### * 두 번째 경우는 다르게 판단해야 하는 작은 값 두 개를 비교하는 경우

x가 나와야 하는 수식과 y가 나와야하는 수식을 각각 계산해 a와 b가 얻어졌다고 가정하면 |a-b|는 |x-y|보다 작을수 있는데

이들이 사실 다르다고 판정하려면 |a-b|보다 오차 한도가 항상 작아야한다. 따라서 |a-b|의 하한을 계산하면 오차 한도의 상한 값을 정할 수 있다.

객관적인 기준이 없으므로

오차 한도의 상한과 하한을 이끌어낼 수 있는 경우에는 이 안에서 적절한 값을 사용하면 된다.

#### 2. 상대 오차를 이용한다.

문제의 입력으로 한 자리가 주어질지 서른 자리가 주어질지 알수 없을 때는 오차한도를 미리 정할 수 없다.

이런 경우 비교하는 숫자들의 크기에 비례하여 오차를 정하는 방식을 사용해야한다. 두 숫자의 크기의 비해 그 차이가 작다면 두 수가 같다고 판정하는 방식

ex ) relativeError(a,b) = |a-b|/max(|a|,|b|)

이렇게 계산한 두 수의 상대 오차가 일정 범위 이하면 같은수록 판정하도록 한다.

그러면 실질적인 오차 허용 범위는 a와 b가 커지면 같이 커진다.

```C++
bool relativeEqual(double a,double b) {
  return fabs(a-b) <= 1e-8 * max(fabs(a),fabs(b));
}
```

이때 비교식의 좌변은 두 수의 절대 차이를 나타내고, 오른쪽은 두 수중 절대 값이 더 큰 수에 0.000001%를 곱한 것을 나타낸다.

우변에 절대 값을 쓰지 않을 경우, 두 값이 모두 음수일 때 relativeEqual()은 항상 거짓만을 반환한다.

이는 완벽한 방법은 아니다. 큰 숫자를 비교할 때보다 작은 숫자들을 비교할 때 문제가 될 수 있다.

어떤 수 x가 0이어야 하는데, 계산 과정에 오차가 누적되어 매우 작은 값 x=0.000000000000001을 대신 얻었다고 하면

relativeError(0,x) = x/x =1이다. 이런문제를 해결하기 위해 두수의 절대 차이가 매우 작을 경우 두수가 같다고 판단해야한다.

-------------------------------------

### 대소 비교

두 수가 같은지를 판단 하는것이 아니라 대소를 판단할 때도 연산오차가 발목을 잡을 수 있는데, 

이 문제를 피하려면 비교할 때 항상 두 값이 같은 경우 다시 말해 두값이 아주 가까운 경우를 먼저 확인하고 처리해 주어야한다.

------------------------------------

### 정확한 사칙연산

실수 변수라고 해서 항상 정확하지 않은 것은 아니다.

IEEE 표준에 의해 실수 변수들은 정확하게 표현할 수 있는 값은 항상 정확하게 저장하도록 구현되어 있다.

따라서 일정 범위와 크기를 갖는 숫자를 다룰 경우에는 사칙연산이 항상 정확하게 이루어지며, 

위와 같은 문제를 생각할 필요 없이 정수변수처럼 다룰 수 있다.

64비트 실수형의 가수부는 52비트 이므로 절대 값이 2^52보다 작은모든 정수들은 항상 정확하게 표현이 가능하다.

----------------------------------------

### 코드의 수치적 안정성 파악하기

프로그램에서 한 연산결과 와 정확한 값의 차이가 0.0000000000001만큼 차이가 났는데 

프로그램이 모두 실행된 뒤 마지막 결과는 정답과 17293만큼 차이난다면, 이 프로그램은 아주 작은 오차를 부풀린셈이고 수치적으로 불안정하다고 말한다.

------------------------------------------

### 실수 연산 아예하지 않기

실수 연산은 제대로 하기 어렵다. 때문에 실수 연산을 제대로 하는 가장 좋은 방법은 실수 연산을 하지 않는 것.

의외로 많은 경우, 얼핏 봐서는 실수 연산을 할 것 같은 문제들에 적절한 변형을 가해 실수 연산을 없앨수 있는데

* 곱셈과 나눗셈의 순서를 바꾸기 : 세 정수 a\b*c를 계산해야하는데, 결과가 항상 정수라는 것을 알고 있다고하면
(a*c)/b형태로 수식을 바꿈으로써 실수 연산을 쓰지 않고 결과를 계산할 수 있다.

* 양변 제곱하기 : 정수 좌표를 갖는 두 점(x1,y1)과 (x2,y2) 사이의 거리가 r 인지 정확하기 확인하고 싶다고 하면
두 점 사이의 거리를 직접 구해서 (x1,y1)^2 + (x2,y2)^2 = r^2 식을 이용하여 정수 연산만으로 확인이 가능하다.

* 실수 좌표를 써야 하는 기하 문제에서 좌표계를 가로 세로로 정수에 늘리면 정수배 늘리면 정수만을 이용해 문제를 풀수 있다.
