### 시간 복잡도

앞 절들에서 가장 깊이 중첩된 반복문의 수행 횟수를 계산했다.

가장 싶이 중첩된 반복문의 내부에 있는 기본적 연산들은 더 쪼갤 수 없기 때문에, 시간 복잡도의 대략적이 기준이 된다.

시간 복잡도가 높다는 말은 입력의 크기가 증가할 때 알고리즘의 수행 시간이 더 빠르게 증가한다는 의미이다.

이 말에 숨어 있는 의미가 있는데, 시간 복잡도가 낮다고 해서 언제나 더 빠르게 동작하는 것은 아니라는것..

입력의 크기가 출분히 작을 때는 시간 복잡도가 높은 알고리즘이 더 빠르게 동작할 수 도 있다.

시간 복잡도가 낮은 알고리즘은 입력이 커지면 커질수록 더 효율적이게 된다.

문제에서 해결할 입력의 크기가 매우 작을 경우 시간 복잡도는 큰 의미를 갖지 못할 수도 있다.

------------------------------------------------

### 입력의 종류에 따른 수행 시간의 변화

그렇다고 입력의 크기가 수행 시간을 결정하는 유일한 척도는 아니다.

입력이 어떤 형태로 구성되어 있는지도 수행 시간에 영향을 미친다.

예를 들어 배열에서 주어진 숫자를 찾아서 그 위치를 반환하는 함수를 구현하면


```C++
int firstIndex(const vector<int> & array,int element) {
  for(int i = 0;i<array.size();++i) {
    if(array[i] == element)
      return i;
  }
  return -1;
}
```

와 같이 있다면 운좋게 처음에 찾을수도 있고, 맨 마지막까지 가야 찾을수 있는 경우도 있다.

이처럼 입력의 종류에 따라 수행 시간이 달라지는 경우를 고려하기 위해 우리는 최선/최악의 경우, 그리고 평균적인 경우에 대한 수행 시간을 각각 따로 계산한다.

```
* 최선의 수행 시간 : 찾으려는 원소가 배열의 맨 앞에 있을 때 알고리즘은 한번 실행되고 종료합니다.
따라서 이 경우 반복문의 수행 횟수는 1이 됩니다.

* 최악의 수행 시간 : 배열에 해당 원소가 없을 때 알고리즘은 N번 반복하고 종료합니다. 
따라서 이 경우 반복문의 수행 횟수는 N이 됩니다.

* 평균적인 경우의 수행 시간: 평균적인 경우의 수행 시간을 분석하기 위해서는 존재할 수 있는 모든 입력의 등장 확률이 모두 같다고 가정하면
주어진 배열이 항상 찾응 원소를 포함한다고 가정하면 반환 값의 기대치는 대략 N/2가 되므로 평균 수행 시간은 N/2다.
```

이 중 사람들이 대개 사용하는 것은 최악의 수행 시간 혹은 수행시간의 기대치 이다. 

------------------------------------------------------------

### 점근적 시간 표기 O표기

시간 복잡도는 알고리즘의 수행 시간을 표기하는 방법이지만, 계산하기 너무 힘들다는 문제가 있다.

한줄 한줄 세는것은 비효율 적이므로 전체 수행 시간에 큰 영향을 미치지 않는 상수 부분은 무시하고 반복문의 반복 수만 고려하게 된다.

여기 대부분 사람들은 간단하게 표현한 대문자 O표기법이라는 것을 사용해 수행히간을 표기한다.

N이 증가할 때 가장 빨리 증가하는 항을 기준을 잡아서 O(N^2) 형식처럼 사용하면된다.

두가지 입력 값이 있다고 하면 ex) 2^N * M = O(2^N * M) 와 같이 표기한다. 

상수의 데이터가 주어지면 우리는 O(1)이라고 표현하고 이런 알고리즘을 상수 시간 알고리즘이라고 부른다.


-----------------------------------------------------------

### O 표기법의 의미

O 표기법은 계산하기 간편하고, 알아보기 쉽다.

하지만 그것만을 원하면 '오래 걸린다' , '금방 끝난다', '적당히 걸린다' 셋중 하나로 수행 시간을 계한하는 체게를 써도 된다.

O 표기법은 대략적으로 함수의 상한을 나타낸다는 의미가 있다. 아래 항 들도 다 떼어내고 상수도 떼어냈는데 함수의 상한이라고 보기엔 의아하다고

생각 할수 있지만 , N이 굉장히 크게 증가한다면 N^2과 N^2 + 100 * N + 1 은 크게 차이가 없다고 볼 수 있다.

O 표기법이 수행 시간의 상한을 나타낸다는 사실을 통해 알고리즘의 최악의 수행 시간을 알아 냈다고

최악의 수행 시간과 관련이 있는 것은 아니다.

퀵 정렬의 최악의 수행 시간은 분석해보면 최고 차항이 N^2 인것을 알 수 있다.

퀵 정렬의 최악의 수행시간은 O(N^2)이다. 하지만 평균ㅇ 수행 시간을 계산해 보면 최고차항이 N logN 이다.

따라서 퀵 정렬의 평균 시간 복잡도는 최악의 경우와 다르다.

------------------------------------------------------------

### 시간 복잡도 분석 연습

코드를 보면서 시간 복잡도 분석을 해보자면 먼저

```C++
void selectionSort(vector<int> &A) {
  for(int i = 0; i < A.size() ;  ++i) {
    int minIn = i ;
    for(int j = i + 1; j < A.size() ; ++j)
      if(A[minIn] > A[j])
        minIn = j;
    swap(A[i] , A[minIn]) ;
  }
}

void insertionSort(vector<int> & A) {
  for(int i = 0; i < A.size() ; ++i) {
    ing j = i;
    while(j > 0 && A[j - 1] > A[j]) {
      swap(A[j-1], A[j]);
      --j;
    }
  }
}
```

와 같이 selectionSort()가 모든 i에 대해 가장 작은 원소를 찾은 뒤, 이것을 A[i]에 넣는 것을 반복한다.

이 알고리즘의 수행 시간은 i가 증가하며 (N-i) 를 N 번하여 N^2/2 - N/2 이므로 O(N^2)이다.

간편하게는 반복문이 두개 겹쳐 있으므로 O(N^2)로 계산해도 된다.

insertionSort()는 삽입 정렬을 구현한 것으로 A[i] 앞에 잇는 정렬된 부분 배열의 적절한 위치에 A[j]를 삽입 해야 하며,

이것이 알고리즘이 삽입 정렬이라고 불리는 이유 이다.

최선의 결과로는 이미 정렬되어 있는 배열이 주어지면 O(1)로 볼 수 있다.

반면 최악의 경우는 while문을 j를 0까지 줄여 가야 하므로 for문에 연산을 중첩으로 해야하므로 전체 시간 복잡도는 O(N^2)가 된다.

이런 약간의 계산을 통해 시간 복잡도를 계산 할 수 있다.

임의의 순열이라고 할 때, 대부분의 경우 삽입 정렬이 선택정렬보다 빠르다. 

-------------------------------------------------------

### 시간 복잡도의 분할 상환 분석

시간 복잡도를 항상 반복문의 개수를 세는 것 만으로 결정하지는 않는다.

 가끔은 문제의 조건에 따라 그 보다 더 정확한 시간 복잡도를 계산하는 것도 가능한데, 그 예가 시간 복잡도의 분할 상환 분석(amoritzed analysis)을 사용하는 것.
 
 분할 상환 분석 =  N명의 신입생이 참여한 신입생 환영회가 열렸다고 가정 한다.
 
 과의 전통에 맞춰 N잔의 막걸리와 특제 소스를 큰 사발에 들이 부어 사발주를 만들었다. 
 
 신입생들은 일렬로 죽 늘어서 맨 왼쪽부터 한 명씩 사발에 든 술을 조금씩 마셔야 한다.
 
 각 개인이 얼마나 마시건 상관 없지만, 마지막 사람까지 사발이 돌고나면 제각각 다르겠지만 N명의 신입생이 N잔의 막거리를 마셧다는
 
 사실은 변하지 않는다. 따라서 평균적으로 각 신입생마다 한 잔의 막걸리를 마셨다고 말할 수 있다.
 
 이 비유를 시간 복잡도 분석에 적용해보면 N개의 작은 작업들을 순서대로 하는데, 각 작업에 걸리는 식나은 모두 다르지만
 
 전체 작업에 걸리는 시간이 일정한 경우 이런 방법을 적용할 수 있다.
 
 각 작업에 걸리는 평균 시간은 전체 시간을 작업의 개수로 나눈 것과 같다.
 
 이런 개념은 괜히 복잡해 보이지만 유용하다. 분할 상환 분석을 이용하면 일반적으로 시간이 오래 걸리는 작업이
 
 시간 안에 돌아가는 것을 이해할 수 있게 된다.
