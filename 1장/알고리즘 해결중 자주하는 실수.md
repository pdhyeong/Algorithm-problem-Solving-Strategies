## 자주하는 실수

### 산술 오버플로

계산과정에서 변수의 표현 범위를 벗어나는 값을 사용하는 산술 오버플로 실수를 자주하기 마련이다.

표현할때 제한사항을 확인하고 사용할것.

-----------------------------------------------

### 배열 범위 밖 원소에 접근

배열 범위 밖의 원소에 접근하는 오류를 범하기 쉽다. C++ / C 는 인덱스가 배열 범위 안에 있는지를 별도로 확인해 주지 않는다.

속도가 중요한 프로그램이 런타임 오류를 내고 종료하는 경우네는 배열 범위 밖에 접근 했다는 사실을 깨달을 수 있지만,

오류도 나지 않으면서 틀린 답만을 내놓는 경우도 더러 있다.

int arr[10],t;

위 와 같이 선언하면 arr[10]의 값에 t에 있던 값이 씌워질 수 있으니 조심한다.

또한 , 0을 시작으로 하는 범위와 1을 시작으로 하는 범위를 혼동하는 것을 조심해야한다.

--------------------------------------------

### 일관되지 않은 범위 표현 방식 사용하기

배열의 잘못된 위치를 참조하는 오류가 발생하는 큰 원인 중 하나로, 프로그램내에서 여러 가지의 범위 표현 방식을 섞어 쓰는 경우가 있다.

---------------------------------------------------
### Off-by-one 오류

Off-by-one 오류는 계산의 큰 줄기는 맞지만 하나가 모자라거나 하나가 많아서 틀리는 코드의 오류를 가르킨다. 예를 들어

100미터인 담장에 10미터 간격으로 울타리 기둥을 세운다고 하면 기둥이 몇개가 필요할까? 정답은 10개가 아니라 11개다

정수 A[]가 주어질 때 A[i]부터 A[j]까지의 평균을 구한다고 하면, 합을 얼마로 나눌까 j-i가 아니라 j-i+1로 나누어야한다.

오류는 반복문에서 < 혹은 > 연산자와 <= 혹은 >= 연산자를 혼동하여 원소를 하나 더 적게,

혹은 많이 순회하는 경우나 반 열린 구간과 닫힌 구간을 서로 혼용해 쓴 경우 흔하게 발생하므로 주의 해야한다.

--------------------------------------------------------------------

### 컴파일러가 잡아주지 못하는 상수 오타

변수명이나 함수명에서 낸 오타는 컴파일러가 잡아준다. 하지만 상수를 잘못 입력해서 문제를 잘 풀어 놓고도 오답 처리 되는 경우를 종종 볼 수 있다.

상수의 타입이나 배열의 크기중 100000과 10000 같이 0의 갯수를 잘못적었는지 확인한다.

-------------------------------------------

### 스택 오버플로

콜 스택이 오버플로해서 프로그램이 강제 종료되는 것 또한 흔히 하는 실수이다. 스택 오버플로는 대개 재귀함수의 깊이가 너무 깊어져서

나오는데, 프로그래밍 대회를 공부하면서 재귀 호출을 사용할 일이 굉장히 많기때문이다.

스택 최대 크기는 컴파일이나 실행시에 설정할 수 있고 기본값이 언어나 아키텍쳐 등에 따라 다르기 때문에 스택 허용량을 알아둘 필요가 있다.

------------------------------------------------

### 잘못된 비교 함수 작성

프로그램 정수 집합을 저장하는 IntegerSet 클래스가 있다고 가정하면 프로그램이 하는 일 중 하나는 vetor<IntegerSet>에 담긴 집합들을 순서대로 처리 하는 것.
  
집합 A가 B의 진부분집합이라면 A는 항상 B보다 먼저 처리되어야 한다. 이 문제를 해결 하기 위 해 IntegerSet의 배열을 정렬하려고 한다. 
  
IntegerSet 처럼사용자가 작성한 클래스를 정렬할 때는 정렬 함수에 비교 함수를 전달하거나, 연산자 오버로딩을 이용해 < 연산을 오버로딩 해야한다.
                                                             
--------------------------------------------

### 다차원 배열 인덱스 순서 바꿔쓰기

2차원 배열 이상의 다차원 배열을 사용할 일이 많지 않지만, 프로그래밍 대회에서는 심심치 않게 4,5차원 이상의 고차원 배열을 사용할때가 있다.

이곳저곳에서 접근하다 보면 한군데 쯤에서 인덱의 순서를 헷갈려서 잘못 쓰는 일이 흔히 있다.

특히 메모제이션 기법을 사용할 때 많이 이용되는데 가능한 특정 배열에 접근하는 위치를 하나로 통일하는 것이 좋다.

----------------------------------------------------------
                                                             
### 최소,최대 예외 잘못 다루기

가능한 입력 중 최소 값과 최대 값이 예외가 되는 문제들은 생각 외로 많으므로, 코드를 짤 때 가장 작은 입력과 가장 큰 입력에 대해 제대로
                                                             
동작할지를 생각해보면 오류를 잡을수 있는 경우가 꽤 많다.

### 연산자 우선 순위 잘못쓰기

시프트 연산자나 비트 단위 연산자들의 우선순의는 종종 헷갈리기 마련이기 때문에

if(b&1==0) 이 b의 최하 비트가 0일 때 참인 것 처럼 보이지만 비트 단위 AND 연산자인 &의 우선순위는 비교 연산자인 ==보다도 낮기때문에
                                                             
실은 if(b&(1==0))와 같이 해석되기 때문에 항상 거짓이 나온다. 이처럼 연산자의 우선순위를 잘 기억해 두어야한다.

----------------------------------------------------------
                                                             
### 너무 느린 입출력 방식 선택

프로그래밍 언어는 택스트를 입출력 할 수 있는 다양한 방법을 제공하는데 C++의 경우 gets()로 모든 입력을 문자열 하나로
                                                             
읽은뒤 파싱이 가능하고, cin 등의 고수준 입력 방식을 사용할 수도 있지만 대개의 경우 고수준 입출력 방식을 이요하면 코드가 간단해지지만
                                                             
cin같은 고수준 입출력 방식이 저수준 방식보다 두 배 이상 느린 경우도 심심찮게 볼 수 있다.
                                                             
입출력 방식의 의해서 정답여부를 바꿀수 있기때문에 어떤 방식을 지원하는지 어느쪽이 빠른지를 미리 점검해두면 좋다.
                                                             
------------------------------------------------
                                                             
### 변수 초기화 문제

프로그래밍 대회에서는 프로그램을 한 번만 실행하고, 한 번에 여러 개의 입력에 대해 답을 처리 하라고 요구한다.
                                                             
흔히 여기서 이전 입력에서 사용한 전벽 변수 값을 초기화 하지 않고 그대로 사용한다. 멤버 변수 들은 생성시에 모두 기본 값으로 초기화
                                                             
되는데, 별도의 초기화를 직접하지 않고 이 행동에 의존했을 경우 두번째 입력부터는 답이 잘못 나올 수 있다.
                                                             
이러한 실수를 그나마 예방하기 위해 예제 입력 파일을 두 번 반복해 쓰는 것. 
                                                             
하지만 완벽하게 방지하는 것은 불가능 하기 때문에 새 테스트 케이스를 처리 할 때마다 변수들을 적절히 초기화 하도록 신경 써서 코딩해야한다.                                                             
                                                             
