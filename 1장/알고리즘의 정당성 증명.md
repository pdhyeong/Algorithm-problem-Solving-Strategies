### 알고리즘의 정당성 증명

문제가 복잡해지면 이 알고리즘이 문제를 제대로 해결하는지를 파악하기 까다로워진다.

단위 테스트를 이용해 여러 개의 입력에 대해 프로그램을 실행해 보고 그 답을 점검해 볼 수도 있지만, 그러면 알고리즘이 존재 가능한

모든 입력에 대해 정확하게 동작하는 사실을 증명할 수 없다.

따라서 알고리즘의 정확한 증명을 위해서는 각종 수학적인 기법이 동원되어야 한다.

99%의 프로그래머는 알고리즘을 새로 만들기 보다 배워서 써먹는 쪽에 지대한 관심을 가지고 있다.

그래서 대개 알고리즘의 증명에 관해서는 일찌감치 잊어버리기 쉽지만 알고리즘을 증명할 수 없으면 제대로 알고있다고 말하기 어렵다.

증명을 이해하는 편이 알고리즘을 사용하는 입자에서도 더 큰 공부가 된다.

내가 설계한 알고리즘의 정당성을 더 쉽게 증명할 수 있다는 것도 또 다른 이유이다.

알고리즘 정당성 증명에 흔히 나타나는 패턴들을 소개하고 몇 가지의 예제 증명들을 다뤄보려고 한다.

<br>

---------------------------------------------------------------------

### 수학적 귀납법과 반복문 불변식

100개의 도미노가 순서대로 놓여 있는 광경을 상상해 보자
```
* 첫 번째 도미노는 직접 손으로 밀어서 쓰러뜨린다.
* 한 도미노가 쓰러지면 다음 도미노 역시 반드시 쓰러진다.
```
그러면 마지막 도미노 또한 당연히 쓰러진다는 것을 직관적으로 알 수 있지요. ***수학적 귀납법*** 은 이와 같이 반복적인 구조를 갖는 명제들을

명제들을 증명하는 데 유용하게 사용되는 증명 기법이다.

귀납법 증명은 크게 세 단계로 나누어진다.

* 단계 나누기 : 증명하고 싶은 사실을 여러 단계로 나눈다.

* 첫 단계 증명 : 첫 단계에서 증명하고 싶은 내용이 성립함을 보인다.

* 귀납 증명 : 한 단계에서 증명하고 싶은 내용이 성립한다면, 다음 단계에서도 성립함을 보인다. 

실제 귀납법을 이용한 증명의 예로 사다리 게임을 생각해보면, 

사다리 게임을 하다보면 맨 위 선택지와 맨 아래 선택지가 언제나 1:1대응이 되는 것이 신기할 때가 있다. 귀납법을 이요하면 이 사실을 쉽게 증명할 수 있다.

* 단계 나누기 : 텅 빈 N개의 세로줄에서부터 시작해서 원하는 사다리 가 될 때 까지 하나씩 가로 줄을 그어 간다고 하자.
이때 가로 줄을 하나 긋는 것을 1단계라고 하자.
* 첫 단계 증명 : 텅 빈 N개의 세로줄에서는 항상 맨 위 선택지와 맨 아래 선택지가 1:1 대응이 된다.
* 귀납 증명 : 가로줄을 그어서 두 개의 세로줄을 연결했다고 하면, 1:1대응은 변하지 않으므로 다음 단계에서도 1:1 속성이 유지 된다.

따라서 귀납법에 의해 가로줄만을 사용하는 사다리 들은 항상 1:1로 대응됨을 알 수 있다.

<br>

-------------------------------------------------------------

### 반복문 불변식

귀납법은 알고리즘의 정당성을 증명할 때 가장 유용하게 사용되는 기법이다.

왜냐면 대부분의 알고리즘은 어떠한 형태로든 반복적인 요소를 가지고 있기 때문이다.

귀납법은 이런 알고리즘들이 옳은 답을 계산함을 보이기 위해서 알고리즘의 각 단계가 정답으로 가는 길 위에 있음을 보이고, 

결과적으로는 알고리즘의 답이 옳음을 보인다.

반복문 불변식이란 반복문의 내용이 한 번 실행될 때마다 중간 결과가 우리가 원하는 답으로 가는길 위에 잘 있는지를 명시하는 조건이다.

반복문이 마지막에 정답을 계산하기 위해서는 항상 이 식이 변하지 않고 성립해야 하기 때문이다.

불변식을 이용하면 반복문의 정당성을 다음과 같이 증명할 수 있다.

```
1. 반복문 진입시에 불변식이 성립함을 보인다.
2. 반복문 내용이 불변식을 깨뜨리지 않음을 보인다. 즉 반복문 내용이 시작할 때 불변식이 성립했다면, 
내용이 끝날 때도 불변식이 항상 성립함을 보인다.
3. 반복문 종료시에 불변식이 성립하면 항상 우리가 정답을 구했음을 보인다.
```
1번 2번 항목을 증명했다면 수학적 귀납법을 이용해 이들은 반복문이 종료할 때까지 항상 이 불변식이 성립함을 보일 수 있다.

<br>

-------------------------------------------------

### 이진 탐색과 반복문 불변식

```C++
int bisearch(const vector<int> &A, int x) {
  int n = A.size();
  int lo = -1, hi = n;
  
  
  while(lo + 1 < hi) {
    int mind = (lo + hi) / 2;
    if(A[mid] < x) {
      lo = mid;
      }
    else {
      hi = mid;
    }
  }
return hi;
}
```

이진 탐색의 한 구현을 보여준 것 이다. 이진 탐색 내부의 while문은 두 개의 불변식을 유지한다.

첫 번째는 lo < hi이고, 두 번째는 A[lo] <= x <= A[hi]이다. 이 불변식이 while문이 완전히 종료하고 함수의 마지막 줄에 올때 까지

계속 성립했다고 가정하면 

* lo + 1 = hi : while문이 종료했으니 lo + 1 >= hi인데 , 불변식에 의하면 lo < hi이니 lo + 1 = hi일 수 밖에 없다.
* A[lo] < r <= A[hi] : 애초에 불변식이 성립한다고 가정했으니, 이것은 당연히 성립한다.

우리가 원하는 결과 값 i는 A[i-1] <= x <= A[i]인 i 이므로 이때 우리가 원하는 답은 hi라는 사실을 쉽게 알 수 있다.

따라서 불변식이 while문 종료시에 항상 성립한다는 것을 보일 수 있다면 이 알고리즘의 정당성은 증명한 셈이다.

반복문이 처음 시작될 때 해당 불변식이 만족함을 보이고, 반복문 내용이 한 번 지나가도 이 조건이 다시 유지됨을 보여 주면 된다.

**초기 조건** : while문이 시작할 때 lo와 hi는 초기값 -1과 n으로 초기화된 상태이다. 만약 n = 0이라면 while문을 아예 건너뛰기 때문에 불변식 1은 항상 성립한다.
우리는 A[-1] = -무한대 이고 A[n] = 무한대 라고 가정하므로 불변식 2 또한 성립한다.

**유지조건** while 문 내부가 불변식을 깨뜨리지 않음을 보이면 된다.

**불변식 1 :** while문 내부로 들어왔다는 말은 hi와 lo의 차이가 2이상이라는 의미이므로 mid는 항상 두 값의 사이에 위치한다.
따라서 mid를 lo에 대입하던 hi에 대입하건 불변식 1은 유지된다.

**불변식 2 :** 
- A[mid] < x 인경우 : 반복문을 시작할 때 x <= A[hi]는 이미 알고있다. 따라서 A[mid] < x <= A[hi]이므로, lo에 mid를 대입해도 항상 성립한다.
- x <= A[mid]인 경우 : 반복문을 시작할 때 알고 있었던 A[lo] < x과 합쳐 보면 A[lo] < x <A[mid]를 얻을 수 있다. 따라서 hi와 mid를 대입해도 불변식 2는 성립한다.

이런 과정을 거쳐서 while문이 종료 될때 우리가 원하는 값이 A[hi]에 저장되어 있음을 알 수 있다.

반복문 불변식은 알고리즘의 정당성을 증명하기 위한 좋은 도구 이다.

<br>

-----------------------------------------------------

### 단정문을 이용해 반복문 불변식 강제하기

잠시 다뤘던 단정문은 반복문 불변식과 아주 잘 어울린다. 불변식을 주석으로만 담아 놓을 것이 아니라 단정문으로 강제해 버리면

해당 불변식이 깨졌을 때 프로그램이 강제 종료되기 때문에 불변식의 유지에 문제가 있다는 사실을 아주 쉽게 알 수 있다.

물론 단정문도 어느 정도 속도에 지장을 주기 때문에 엄청나게 많이 실행되는 반복문 안에 단정문을 배치하는 것은 삼가하는 것이 좋다.

