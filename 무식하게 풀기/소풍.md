### 문제

안드로메다 유치원 익스프레스반에서는 다음 주에 율동공원으로 소풍을 갑니다.

원석 선생님은 소풍 때 학생들을 두 명씩 짝을 지어 행동하게 하려고 합니다. 

그런데 서로 친구가 아닌 학생들끼리 짝을 지어 주면 서로 싸우거나 같이 돌아다니지 않기 때문에, 

항상 서로 친구인 학생들끼리만 짝을 지어 줘야 합니다.

각 학생들의 쌍에 대해 이들이 서로 친구인지 여부가 주어질 때, 

학생들을 짝지어줄 수 있는 방법의 수를 계산하는 프로그램을 작성하세요. 

짝이 되는 학생들이 일부만 다르더라도 다른 방법이라고 봅니다. 예를 들어 다음 두 가지 방법은 서로 다른 방법입니다.

```
(태연,제시카) (써니,티파니) (효연,유리)
(태연,제시카) (써니,유리) (효연,티파니)
```

-----------------------------------------

### 입력

입력의 첫 줄에는 테스트 케이스의 수 C (C <= 50) 가 주어집니다. 

각 테스트 케이스의 첫 줄에는 학생의 수 n (2 <= n <= 10) 과 친구 쌍의 수 m (0 <= m <= n*(n-1)/2) 이 주어집니다.

그 다음 줄에 m 개의 정수 쌍으로 서로 친구인 두 학생의 번호가 주어집니다. 번호는 모두 0 부터 n-1 사이의 정수이고, 같은 쌍은 입력에 두 번 주어지지 않습니다.

학생들의 수는 짝수입니다.

---------------------------------------------------------

### 출력

각 테스트 케이스마다 한 줄에 모든 학생을 친구끼리만 짝지어줄 수 있는 방법의 수를 출력합니다.

---------------------------------------------

### 예제 입력
```
3 
2 1 
0 1 
4 6 
0 1 1 2 2 3 3 0 0 2 1 3 
6 10 
0 1 0 2 1 2 1 3 1 4 2 3 2 4 3 4 3 5 4 5
```

### 예제 출력

1

3

4

-----------------------------------------------

### 중복으로 세는 문제

중복을 상관하지 않고 문제를 해결하면 2 24 192라는 값이 나온다

이 말은 우리가 한경우를 중복으로 여러번 세고 있다는 말인데

실질적으로 같은 답을 중복으로 세는 이런 상황은 경우의 수를 다룰 때 굉장히 흔하게 마주친다.

같은 답 중에서 사전순으로 가장 먼저 오는 답 하나만을 세면 이 속성을 강제가 가능한데

각 단계에서 남아 있는 학생들 중 가장 번호가 빠른 학생의 짝을 찾아 주도록 하면 된다.

가장 번호가 빠른 학생의 짝은 그 보다 번호가 뒤일 수 밖에 없기 때문이다.

---------------------------
### CODE

```C++
int n;
bool af[10][10];
int countpairs(bool taken[10]) {

//가장 빠른 번호학생 변수
	int firstFree = -1;
	for (int i = 0; i < n; i++)
	{
  // taken[i]번째 학생이 짝을 이미 찾았으면 true 아니면 false
		if (!taken[i]) {
			firstFree = i;
			break;
		}
	}
	if (firstFree == -1) return 1;
	int ret = 0;
  
  // 오른쪽으로 순회하면서 한 학생과 짝지을 학생을 결정한다.
	for (int pairwith = firstFree; pairwith < n; ++pairwith)
	{
		if (!taken[pairwith] && af[firstFree][pairwith]) {
			taken[firstFree] = taken[pairwith] = true;
			ret += countpairs(taken);
			taken[firstFree] = taken[pairwith] = false;
		}
	}
	return ret;
}

int main() {

  int testCase, start = 0, pair;
	bool taken[10];

	cin >> testCase;

	while (testCase--)
	{
		memset(af, false, sizeof(af));
		memset(taken, false, sizeof(taken));

		cin >> n >> pair;
		for (int i = 0; i < pair; i++) {
			int try1, try2;
			cin >> try1 >> try2;
			af[try1][try2] = true;
			af[try2][try1] = true;
		}
		cout << "output : " << countpairs(taken) << endl;
	}
	return 0;
}
```

--------------------------

### 답의 수의 상한

모든 답을 생성해 가며 답의 수를 세는 재귀 호출 알고리즘은 답의 수에 정비례하는 시간이 걸린다.

따라서 실제로 프로그램을 짜기 전에 답의 수를 얼마나 될지 예측해보고 답을 만드는 데 시간이 얼마나 오래 걸릴지를 확인해야한다.

이 문제에서는 열 명의 학생이 모두 서로 친구인 경우이다. 가장 번호가 빠른 학생이 선택할 수 있는 짝은 9명이고, 그 다음 학생은 7명

이와 같이 최종 답의 상한수는 9 * 7 * 5 * 3 * 1 = 945가 된다.
