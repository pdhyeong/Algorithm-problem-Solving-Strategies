### 문제

![image](https://user-images.githubusercontent.com/71219602/187024404-aea7dfcd-e1cc-4065-be95-81dad1660af5.png)


보글(Boggle) 게임은 그림 (a)와 같은 5x5 크기의 알파벳 격자인 게임판의 한 글자에서 시작해서 펜을 움직이면서 만나는 글자를 그 순서대로 나열하여 만들어지는 영어 단어를 찾아내는 게임입니다. 

펜은 상하좌우, 혹은 대각선으로 인접한 칸으로 이동할 수 있으며 글자를 건너뛸 수는 없습니다.

지나간 글자를 다시 지나가는 것은 가능하지만, 펜을 이동하지않고 같은 글자를 여러번 쓸 수는 없습니다.

예를 들어 그림의 (b), (c), (d)는 각각 (a)의 격자에서 PRETTY, GIRL, REPEAT을 찾아낸 결과를 보여줍니다.

보글 게임판과 알고 있는 단어들의 목록이 주어질 때, 보글 게임판에서 각 단어를 찾을 수 있는지 여부를 출력하는 프로그램을 작성하세요.

주의: 알고리즘 문제 해결 전략 6장을 읽고 이 문제를 푸시려는 분들은 주의하세요. 

6장의 예제 코드는 이 문제를 풀기에는 너무 느립니다. 6장의 뒷부분과 8장을 참조하세요.

--------------------------------------

### 입력

입력의 첫 줄에는 테스트 케이스의 수 C(C <= 50)가 주어집니다.

각 테스트 케이스의 첫 줄에는 각 5줄에 5글자로 보글 게임판이 주어집니다.  게임판의 모든 칸은 알파벳 대문자입니다.

그 다음 줄에는 우리가 알고 있는 단어의 수 N(1 <= N <= 10)이 주어집니다. 

그 후 N줄에는 한 줄에 하나씩 우리가 알고 있는 단어들이 주어집니다. 

각 단어는 알파벳 대문자 1글자 이상 10글자 이하로 구성됩니다.

--------------------------------------

### 출력

각 테스트 케이스마다 N줄을 출력합니다.

각 줄에는 알고 있는 단어를 입력에 주어진 순서대로 출력하고, 해당 단어를 찾을 수 있을 경우 YES, 아닐 경우 NO를 출력합니다.

--------------------------------------

### 예제 입력

```
1
URLPM
XPRET
GIAET
XTNZY
XOQRS
6
PRETTY
GIRL
REPEAT
KARA
PANDORA
GIAZAPX
```
### 예제 출력

```
PRETTY YES
GIRL YES
REPEAT YES
KARA NO
PANDORA NO
GIAZAPX YES
```

------------------------

### 문제의 분할

hasword()의 기능은 각 글자를 하나의 조각으로 만드는 것.

함수 호출시에 단어의 시작 위치를 정해주기 때문에, 문제의 조각들 중 첫 번째 글자에 해당하는 조각을 간단하게 해결할 수 있다.

즉, 첫 글자가 다르면 바로 false를 반환 하고 종료가 가능하기 때문이다.

시작단어 위치를 기점으로 인접한 8칸을 모두 시도하여 답을 찾으면 된다.

------------------------

### 기저사례의 선택
```
1. 글자가 원하는 단어의 첫 글자가 아닌 경우 항상 실패
2. 원하는 단어가 한 글자인 경우 항상 성공
```
하지만 위 두 조건의 순서는 지켜져야한다.

------------------------

### CODE

```C++
const int dx[8] = {-1,-,1 -1, 1, 1, 1, 0 ,0};
const int dy[8] = {-1, 0, 1, -1, 0, 1, -1, 1};

bool hasword(int y,int x, const string &word) {

  if(!Range(y,x)) return false;

  if(board[y][x] != word[0]) return false;

  if(word.size() == 1) return true;

  for(int direction = 0;direction < 8;++direction) {
    int ny = y + dy[direction], nx = x + dx[direction];
  
    if(hasword(ny,nx,word.substr(1))
      return true;
  }
  return false;
}
```
------------------------

### 시간복잡도 분석

가능한 답 후보들을 확인하는 완전탐색 알고리즘이기 때문에, 시작 위치에서 시작하는 모든 후보들을 빠짐없이 검사 하면된다.

검사하게 되는 후보의 수는 최대 8^n-1)이기 때문에 O(8^n)이 된다.

지수적으로 증가하기 때문에 단어가 짧은 경우에만 해당 알고리즘으로 해결이 가능하다.

------------------------

### 완전 탐색 레시피
```
1. 완전 탐색은 모든 답을 하나씩 검사하므로, 가능한 답의 수에 정확히 비례한다. 최대 크기의 입력을 가정했을 때 답의 개수를 계산하고 제한 시간을 파악한다.

2. 가능한 모든 답의 후보를 만드는 과정을 여러 개의 선택으로 나눈다.

3. 하나의 조각을 선택해 답의 일부를 만들고, 나머지 답을 재귀호출을 통해 완성

4. 조각이 하나밖에 남지 않은 경우나 하나도 남지 않은 경우는 답을 생성했을므로 이것을 기저 사례로 선택해 처리
```
------------------------

### 이론적 배경 : 재귀 호출과 부분 문제

재귀 호출의 중요한 개념 중 문제와 부분 문제의 정의가 있다.

간단하게 예를 들면

주어진 자연수 수열을 정렬하라 라는 문제와 {16,7,9,1,31}을 정렬하라 라는 문제의 차이이다.

두 문제는 특정한 입력을 지정하냐 안하냐의 차이가 있다.

이는 보글 게임에서 '게임판에서의 현재 위치 그리고 단어가 주어질 때 해당 단어를 이 칸에서부터 시작해서 찾을 수 있는지'를 정의하게 된다.

해당 단어를 이 위치에서 찾을 수 있는지를 알기 위해 최대 9가지 정보를 알아야 된다.
```
1. 현재 위치(y,2)에 단어의 첫 글자가 있는가?
2. 윗 칸(y-1,x)에서 시작해서 단어의 나머지 글자들을 찾을 수 있는가?
3. 왼쪽 위 칸(y-1,x-1)에서 시작해서 단어의 나머지 글자들을 찾을 수 있는가?
4 ....
```
2번 이후의 항목은 원래 문제에서 한 조각을 떼어냈을 뿐, 형식이 같은 또 다른 문제를 푼 결과이다.

문제를 구성하는 조각들 중 하나를 뺐기 때문에 문제의 일부라고 말할 수 있고, 이런 문제들을 원래 문제의 부분 문제라고 한다.

